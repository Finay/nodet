<!doctype html>
<html>
    <head>
        <style>
            :root {
                --bgdark: #ede8d7;
                --bglight: #fcf6e5;
                --borderdark: #96a0a1;
                --borderlight: #e2e1de;
                --blue: #4689cc;
                --green: #8d9b31;
                --red: #cb4239;
                --turq: #519f98;
                --text: #6a7b82;
            }

            body,
            html {
                margin: 0;
                padding: 0;
                overflow: hidden;
            }
            #container {
                display: flex;
            }
            #graphview {
                width: 50vw;
                height: 100vh;
                background-color: var(--bglight);
                border-right: var(--borderdark) 1px solid;
            }
            #textviews {
                width: 50vw;
                height: 100vh;
            }
            #editorview {
                width: 100%;
                height: 50%;
                background-color: var(--bglight);
                border-left: var(--borderdark) 1px solid;
                border-bottom: var(--borderdark) 1px solid;
            }
            #navigatorview {
                width: 100%;
                height: 50%;
                background-color: var(--bglight);
                border-left: var(--borderdark) 1px solid;
                border-top: var(--borderdark) 1px solid;
            }
        </style>
    </head>
    <body>
        <div id="container">
            <div id="graphview"></div>
            <div id="textviews">
                <div id="editorview"></div>
                <div id="navigatorview"></div>
            </div>
        </div>
        <script type="module">
            import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";

            // Globals
            let simulatednodes = [
                { id: "cf0b19f251f438", title: "Idea 1", group: "A" }, // Math.random().toString(16).slice(2)
                { id: "1c0e0c501d58f8", title: "Idea 2", group: "B" },
            ];
            let simulatedlinks = [
                { source: "cf0b19f251f438", target: "1c0e0c501d58f8" },
            ];

            let primarynodeid = "cf0b19f251f438";
            let secondarynodeid = "1c0e0c501d58f8";

            const chartwidth = graphview.offsetWidth;
            const chartheight = graphview.offsetHeight;

            const simulation = d3
                .forceSimulation(simulatednodes)
                .force(
                    "link",
                    d3
                        .forceLink(simulatedlinks)
                        .id((link) => link.id)
                        .strength((link) => 1),
                )
                .force("charge", d3.forceManyBody());

            const svg = d3
                .create("svg")
                .attr("width", chartwidth)
                .attr("height", chartheight)
                .attr("viewBox", [
                    -chartwidth / 2,
                    -chartheight / 2,
                    chartwidth,
                    chartheight,
                ])
                .attr("style", "max-width: 100%; height: auto;")
                .call(
                    d3
                        .zoom()
                        .extent([
                            [0, 0],
                            [chartwidth, chartheight],
                        ])
                        .scaleExtent([1, 8])
                        .on("zoom", ({ transform }) => {
                            graphlinks.attr("transform", transform);
                            graphnodes.attr("transform", transform);
                        }),
                );

            let graphlinks = svg
                .append("g")
                .selectAll("line")
                .data(simulatedlinks)
                .join("line");

            let graphnodes = svg
                .append("g")
                .selectAll("circle")
                .data(simulatednodes, (node) => node.id)
                .join("circle");

            simulation.on("tick", () => {
                graphlinks
                    .attr("x1", (link) => link.source.x)
                    .attr("y1", (link) => link.source.y)
                    .attr("x2", (link) => link.target.x)
                    .attr("y2", (link) => link.target.y);

                graphnodes
                    .attr("cx", (node) => node.x)
                    .attr("cy", (node) => node.y);
            });

            function updatenodestructure(nodes, links) {
                simulation.nodes(nodes);
                simulation.force("link").links(links);
                simulation.alpha(1).restart();

                graphnodes = graphnodes
                    .data(nodes, (node) => node.id)
                    .join((enter) => enter.append("circle"));

                graphlinks = graphlinks
                    .data(
                        links,
                        (link) => `${link.source.id}\t${link.target.id}`,
                    )
                    .join("line");
            }

            function nodestructureupdated() {
                graphnodes.call(
                    d3
                        .drag()
                        .on("start", (event) => {
                            if (!event.active)
                                simulation.alphaTarget(0.3).restart();
                            event.subject.fx = event.subject.x;
                            event.subject.fy = event.subject.y;
                        })
                        .on("drag", (event) => {
                            event.subject.fx = event.x;
                            event.subject.fy = event.y;
                        })
                        .on("end", (event) => {
                            if (!event.active) simulation.alphaTarget(0);
                            event.subject.fx = null;
                            event.subject.fy = null;
                        }),
                );
            }

            function nodestrokecolor(node) {
                return node.id == primarynodeid ? "#000" : "#fff";
            }

            const nodecolorscale = d3.scaleOrdinal(d3.schemeCategory10);

            function nodestrokeopacity(node) {
                return node.id == primarynodeid ? 0.6 : 1;
            }

            function isselectedlink(link) {
                return (
                    (primarynodeid == link.source.id &&
                        secondarynodeid == link.target.id) ||
                    (primarynodeid == link.target.id &&
                        secondarynodeid == link.source.id)
                );
            }

            function linkcolor(link) {
                return isselectedlink(link) ? "#000" : "#999";
            }

            function linkstrokewidth(link) {
                return isselectedlink(link) ? 2 : 1;
            }

            function nodestylingupdated() {
                graphnodes
                    .attr("r", 5)
                    .attr("stroke", (node) => nodestrokecolor(node))
                    .attr("stroke-opacity", (node) => nodestrokeopacity(node))
                    .attr("stroke-width", 1.5)
                    .attr("fill", (node) => nodecolorscale(node.group));
                graphlinks
                    .attr("stroke", (link) => linkcolor(link))
                    .attr("stroke-opacity", 0.6)
                    .attr("stroke-width", (link) => linkstrokewidth(link));
            }

            function getneighbors(nodeid) {
                return graphlinks.data().reduce((neighbors, link) => {
                    if (link.target.id === nodeid) {
                        neighbors.push(link.source.id);
                    } else if (link.source.id === nodeid) {
                        neighbors.push(link.target.id);
                    }
                    return neighbors;
                }, []);
            }

            function getnextneighborid(
                step = 1,
                targetnodeid = primarynodeid,
                targetneighborid = secondarynodeid,
            ) {
                const neighbornodeids = getneighbors(targetnodeid);
                if (neighbornodeids.length == 0) {
                    alert("Neighbor search returned empty.");
                }
                const index = neighbornodeids.indexOf(targetneighborid);
                if (index == -1) {
                    return neighbornodeids[0];
                } else {
                    return neighbornodeids[
                        (index + step + neighbornodeids.length) %
                            neighbornodeids.length
                    ];
                }
            }

            // graphwalk
            addEventListener("keydown", (event) => {
                if (event.code == "KeyD") {
                    secondarynodeid = getnextneighborid();
                } else if (event.code == "KeyA") {
                    secondarynodeid = getnextneighborid(-1);
                } else if (event.code == "KeyW") {
                    const temp = primarynodeid;
                    primarynodeid = secondarynodeid;
                    secondarynodeid = temp;

                    secondarynodeid = getnextneighborid();
                } else if (event.code == "KeyS") {
                    secondarynodeid = getnextneighborid(-1);

                    const temp = primarynodeid;
                    primarynodeid = secondarynodeid;
                    secondarynodeid = temp;
                } else if (event.code == "KeyI") {
                    let newnodeid = Math.random().toString(16).slice(2);
                    let oldnodesdata = graphnodes.data();
                    oldnodesdata.push({ id: newnodeid, title: "", group: "" });
                    let oldlinksdata = graphlinks.data();
                    oldlinksdata.push({
                        source: primarynodeid,
                        target: newnodeid,
                    });
                    secondarynodeid = primarynodeid;
                    primarynodeid = newnodeid;

                    updatenodestructure(oldnodesdata, oldlinksdata);
                    nodestructureupdated();
                } else if (event.key == "1") {
                    download(
                        JSON.stringify({
                            nodes: graphnodes.data(),
                            links: graphlinks.data(),
                        }),
                        "json.txt",
                        "text/plain",
                    );
                } else {
                    return;
                }

                nodestylingupdated();
            });

            // Download & Upload
            function download(content, fileName, contentType) {
                var a = document.createElement("a");
                var file = new Blob([content], { type: contentType });
                a.href = URL.createObjectURL(file);
                a.download = fileName;
                a.click();
            }

            addEventListener("dragover", function (event) {
                event.preventDefault();
            });

            addEventListener("drop", (ev) => {
                ev.preventDefault();
                async function getDrop() {
                    const text = await [...ev.dataTransfer.items][0]
                        .getAsFile()
                        .text();
                    console.log(JSON.parse(text));
                    const { nodes, links } = JSON.parse(text);
                    updatenodestructure(nodes, links);
                    nodestructureupdated();
                    nodestylingupdated();
                }
                getDrop();
            });

            // finalize initial graph and add to view
            nodestructureupdated();
            nodestylingupdated();
            graphview.append(svg.node());
        </script>
    </body>
</html>
